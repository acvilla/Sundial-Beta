// This file is generated by Ember Desktop.  Please do not edit manually.
//
//

// This callback file is created for your convenience. You may add application
// code to this file. If you regenerate this file over a previous version, the
// previous version will be overwritten and any code you have added will be
// lost.
#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include "stack/include/ember.h"
#include "command-interpreter/command-interpreter.h"
#include "hal/hal.h"
#include "serial/serial.h"
#include "em_burtc.h"
#include "em_chip.h"
#include "em_cmu.h"
#include "em_device.h"
#include "em_emu.h"
#include "em_rmu.h"

#include "clock.h"
#include "clock_config.h"
#include "clockApp_stk.h"

/* Declare variables */
static uint32_t resetcause = 0;

/* Calendar struct for initial date setting */
static struct tm initialCalendar;


/* Function prototypes */
void budSetup( void );
void burtcSetup( void );

/***************************************************************************//**
 * @brief Set up backup domain.
 ******************************************************************************/
void budSetup(void)
{
	 /* Assign default TypeDefs */
	  EMU_EM4Init_TypeDef em4Init = EMU_EM4INIT_DEFAULT;
	  EMU_BUPDInit_TypeDef bupdInit = EMU_BUPDINIT_DEFAULT;

	  /*Setup EM4 configuration structure */
	  em4Init.lockConfig = true;
	  em4Init.osc = emuEM4Osc_LFXO;
	  em4Init.buRtcWakeup = false;
	  em4Init.vreg = true;

	  /* Setup Backup Power Domain configuration structure */
	  bupdInit.probe = emuProbe_Disable;
	  bupdInit.bodCal = false;
	  bupdInit.statusPinEnable = false;
	  bupdInit.resistor = emuRes_Res0;
	  bupdInit.voutStrong = false;
	  bupdInit.voutMed = false;
	  bupdInit.voutWeak = false;
	  bupdInit.inactivePower = emuPower_MainBU;
	  bupdInit.activePower = emuPower_MainBU;
	  bupdInit.enable = true;

	  /* Unlock configuration */
	  EMU_EM4Lock( false );

	  /* Initialize EM4 and Backup Power Domain with init structs */
	  EMU_BUPDInit( &bupdInit );
	  EMU_EM4Init( &em4Init );

	  /* Release reset for backup domain */
	  RMU_ResetControl( rmuResetBU, false );

	  /* Lock configuration */
	  EMU_EM4Lock( true );
}


/******************************************************************************
 * @brief   Configure backup RTC
 *****************************************************************************/
void burtcSetup(void)
{
  /* Create burtcInit struct and fill with default values */
  BURTC_Init_TypeDef burtcInit = BURTC_INIT_DEFAULT;

  /* Set burtcInit to proper values for this application */
  /* To make this example easier to read, all fields are listed,
     even those which are equal to their default value */
  burtcInit.enable = false;
  burtcInit.mode = burtcModeEM4;
  burtcInit.debugRun = false;
  burtcInit.clkSel = burtcClkSelLFXO;
  burtcInit.clkDiv = burtcClkDiv_128;
  burtcInit.timeStamp = true;
  burtcInit.compare0Top = false;
  burtcInit.lowPowerMode = burtcLPDisable;

  /* Initialize BURTC with burtcInit struct */
  BURTC_Init( &burtcInit );

    /* Enable BURTC interrupt on compare match and counter overflow */
  BURTC_IntEnable( BURTC_IF_COMP0 | BURTC_IF_OF );
}



// The Simulated EEPROM callback function, implemented by the
// application.
void halSimEepromCallback(EmberStatus status) {
 // your code here
}

/** @brief Ok To Sleep
 *
 * This function is called by the Idle/Sleep plugin before sleeping.  It is
 * called with interrupts disabled.  The application should return TRUE if the
 * device may sleep or FALSE otherwise.
 *
 * @param durationMs The maximum duration in milliseconds that the device will
 * sleep.  Ver.: always
 */
bool emberAfPluginIdleSleepOkToSleepCallback(uint32_t durationMs) {
 // your code here
}

/** @brief Wake Up
 *
 * This function is called by the Idle/Sleep plugin after sleeping.
 *
 * @param durationMs The duration in milliseconds that the device slept.  Ver.:
 * always
 */
void emberAfPluginIdleSleepWakeUpCallback(uint32_t durationMs) {
 // your code here
}

/** @brief Ok To Idle
 *
 * This function is called by the Idle/Sleep plugin before idling.  It is called
 * with interrupts disabled.  The application should return TRUE if the device
 * may idle or FALSE otherwise.
 *
 */
bool emberAfPluginIdleSleepOkToIdleCallback(void) {
 // your code here
}

/** @brief Active
 *
 * This function is called by the Idle/Sleep plugin after idling.
 *
 */
void emberAfPluginIdleSleepActiveCallback(void) {
 // your code here
}

/** @brief Main Init
 *
 * This function is called when the application starts and can be used to
 * perform any additional initialization required at system startup.
 */
void emberAfMainInitCallback(void) {
	  /* Read and clear RMU->RSTCAUSE as early as possible */
	  resetcause = RMU->RSTCAUSE;
	  RMU_ResetCauseClear();

	  /* Enable clock to low energy modules */
	  CMU_ClockEnable(cmuClock_CORELE, true);

	  /* Configure Backup Domain */
	  budSetup();

	  /* Setting up a structure to initialize the calendar
	     for 1 January 2012 12:00:00
	     The struct tm is declared in time.h
	     More information for time.h library in http://en.wikipedia.org/wiki/Time.h */
	  initialCalendar.tm_sec    =  0;    /* 0 seconds (0-60, 60 = leap second)*/
	  initialCalendar.tm_min    =  0;    /* 0 minutes (0-59) */
	  initialCalendar.tm_hour   =  0;    /* 0 hours (0-23) */
	  initialCalendar.tm_mday   =  1;    /* 1st day of the month (1 - 31) */
	  initialCalendar.tm_mon    =  0;    /* January (0 - 11, 0 = January) */
	  initialCalendar.tm_year   =  112;  /* Year 2012 (year since 1900) */
	  initialCalendar.tm_wday   =  0;    /* Sunday (0 - 6, 0 = Sunday) */
	  initialCalendar.tm_yday   =  0;    /* 1st day of the year (0-365) */
	  initialCalendar.tm_isdst  =  -1;   /* Daylight saving time; enabled (>0), disabled (=0) or unknown (<0) */

	  /* Set the calendar */
	  clockInit(&initialCalendar);

	  /* If waking from backup mode, restore time from retention registers */
	  if (    (resetcause & RMU_RSTCAUSE_BUMODERST)
	      && !(resetcause & RMU_RSTCAUSE_BUBODREG)
	      && !(resetcause & RMU_RSTCAUSE_BUBODUNREG)
	      && !(resetcause & RMU_RSTCAUSE_BUBODBUVIN)
	      &&  (resetcause & RMU_RSTCAUSE_BUBODVDDDREG)
	      && !(resetcause & RMU_RSTCAUSE_EXTRST)
	      && !(resetcause & RMU_RSTCAUSE_PORST) )
	  {
	    /* Initialize display application */
	    clockAppInit();

	    /* Restore time from backup RTC + retention memory and print backup info*/
	    clockAppRestore();

	    /* Clear BURTC timestamp */
	    BURTC_StatusClear();
	  }

	  /* If normal startup, initialize application and start BURTC */
	  else
	  {
	    /* Start LFXO and wait until it is stable */
	    CMU_OscillatorEnable(cmuOsc_LFXO, true, true);

	    /* Setup BURTC */
	    burtcSetup();

	    /* Initialize display application */
	    clockAppInit();

	    /* Start BURTC */
	    BURTC_Enable( true );

	    /* Backup initial calendar (initialize retention registers) */
	    clockAppBackup();
	  }

	  /* Enable BURTC interrupts */
	  NVIC_ClearPendingIRQ( BURTC_IRQn );
	  NVIC_EnableIRQ( BURTC_IRQn );

}

/** @brief Main Tick
 *
 * This function is called in each iteration of the main application loop and
 * can be used to perform periodic functions.  The frequency with which this
 * function is called depends on how quickly the main loop runs.  If the
 * application blocks at any time during the main loop, this function will not
 * be called until execution resumes. Sleeping and idling will block.
 */
void emberAfMainTickCallback(void) {
	clockAppDisplay();// your code here
}

/** @brief Stack Status
 *
 * This function is called when the stack status changes.  This callbacks
 * provides applications an opportunity to be notified of changes to the stack
 * status and take appropriate action.
 *
 * @param status   Ver.: always
 */
void emberAfStackStatusCallback(EmberStatus status) {
 // your code here
}

/** @brief Incoming Message
 *
 * This function is called when a message is received.
 *
 * @param message   Ver.: always
 */
void emberAfIncomingMessageCallback(EmberIncomingMessage *message) {
 // your code here
}

/** @brief Message Sent
 *
 * This function is called to indicate whether an outgoing message was 
 * successfully transmitted or to indicate the reason of failure.
 *
 * @param status    Ver.: always
 * @param message   Ver.: always
 */
void emberAfMessageSentCallback(EmberStatus status, 
                                EmberOutgoingMessage *message) {
 // your code here
}

/** @brief Child Join
 *
 * This function is called when a node has joined the network.
 *
 * @param nodeType   Ver.: always
 * @param nodeId     Ver.: always
 */
void emberAfChildJoinCallback(EmberNodeType nodeType,
                              EmberNodeId nodeId) {
 // your code here
}

/** @brief Active Scan Complete
 *
 * This function is called when a node has completed an active scan.
 */
void emberAfActiveScanCompleteCallback(void) {
 // your code here
}

/** @brief Child Join
 *
 * This function is called when a node has joined the network.
 *
 * @param mean       Ver.: always
 * @param min        Ver.: always
 * @param max        Ver.: always
 * @param variance   Ver.: always
 */
void emberAfEnergyScanCompleteCallback(int8_t mean,
                                       int8_t min,
                                       int8_t max,
                                       uint16_t variance) {
 // your code here
}

/** @brief Incoming Beacon
 *
 * This function is called when a node is performing an active scan and a beacon
 * is received.
 *
 * @param panId          Ver.: always
 * @param nodeId         Ver.: always
 * @param payloadLength  Ver.: always
 * @param payload        Ver.: always
 */
void emberAfIncomingBeaconCallback(EmberPanId panId,
                                   EmberNodeId nodeId,
                                   uint8_t payloadLength,
                                   uint8_t *payload) {
 // your code here
}

