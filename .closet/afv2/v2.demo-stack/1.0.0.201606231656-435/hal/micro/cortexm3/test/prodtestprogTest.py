#!/usr/bin/env python
#
# This test takes a one argument
# 1) The hostname of the JLink to use. The hostname can be of the form:
#  usb:0
#  ip:127.0.0.1
#
# This test code depends on the jlink cygwin package library (installed for
# Salina execution).  The only precondition to running this test code is that a
# prodtestprog.hex file exists in the same directory and has been generated by:
# ./prodtestprogToHex.py ../../../../build/prodtestprog-ram-em3xx-cortexm3-iar-em350-em350-dev0680-ramexe/prodtestprog-ram-em3xx.s37
# This code is capable of programming the chip directly from the hex file
# and executing a variety of tests.
#
# Author: Brooks Barrett
#
# * Copyright 2009 by Ember Corporation.  All rights reserved.              *80*
################################################################################

import os
import sys
import time
import jlink

COMMAND_IDLE                         = 0xAAAA
COMMAND_PROGRAM                      = 0xCCCC
COMMAND_READ_MODIFY_WRITE            = 0x9999
STATUS_IDLE_AND_READY                = 0xF0F0
STATUS_BUSY                          = 0xA5A5
STATUS_INVALID_COMMAND_FAILURE       = 0xC3C3
STATUS_NEW_DATA_CHECKSUM_FAILURE     = 0x9696
STATUS_PROG_NOT_EMPTY_FAILURE        = 0xFF00
STATUS_PROG_INHIBIT_FAILURE          = 0xAA55
STATUS_VERIFY_PROG_FAILURE           = 0xCC33
STATUS_VERIFY_ERASE_FAILURE          = 0x9966
STATUS_SORT_MARKERS_INVALID_FAILURE  = 0xF00F
STATUS_SUCCESS                       = 0xA55A
STATUS_RAM_CODE_CHECKSUM_FAILURE     = 0xC33C
_UNUSED2_                            = 0x9669
cmdstatDict = {
0xAAAA:"COMMAND_IDLE"                       ,
0xCCCC:"COMMAND_PROGRAM"                    ,
0x9999:"COMMAND_READ_MODIFY_WRITE"          ,
0xF0F0:"STATUS_IDLE_AND_READY"              ,
0xA5A5:"STATUS_BUSY"                        ,
0xC3C3:"STATUS_INVALID_COMMAND_FAILURE"     ,
0x9696:"STATUS_NEW_DATA_CHECKSUM_FAILURE"   ,
0xFF00:"STATUS_PROG_NOT_EMPTY_FAILURE"      ,
0xAA55:"STATUS_PROG_INHIBIT_FAILURE"        ,
0xCC33:"STATUS_VERIFY_PROG_FAILURE"         ,
0x9966:"STATUS_VERIFY_ERASE_FAILURE"        ,
0xF00F:"STATUS_SORT_MARKERS_INVALID_FAILURE",
0xA55A:"STATUS_SUCCESS"                     ,
0xC33C:"STATUS_RAM_CODE_CHECKSUM_FAILURE"   ,
0x9669:"_UNUSED2_"
}


#Shared Memory sizes and locations are defined in the method loadHexToChip()


TEST_DATA_INCREMENT = []
TEST_DATA_FFFF = []
TEST_DATA_0000 = []


#The input data must be an array with each item in the array a 16bit number.
#If no length parameter is specified, the method will operate on the entire
#data list.  Length parameter let's the caller decided to restrict calculation..
def calculateFletcher32Checksum(data, length=None):
  if length is None:
    length = len(data)
  
  dataIndex = 0
  
  sum1 = 0xFFFF
  sum2 = 0xFFFF
  
  while(length):
    if(length > 360):
      tLength = 360
    else:
      tLength = length
    
    length -= tLength
    
    for i in xrange(tLength):
      sum1 = sum1 + data[dataIndex]
      sum2 = sum2 + sum1
      dataIndex = dataIndex + 1
    
    sum1 = (sum1 & 0xFFFF) + (sum1 >> 16)
    sum2 = (sum2 & 0xFFFF) + (sum2 >> 16)
  
  #This reduction step is for reducing the sums to 16 bits
  sum1 = (sum1 & 0xFFFF) + (sum1 >> 16)
  sum2 = (sum2 & 0xFFFF) + (sum2 >> 16)
  
  result = (sum2 << 16) | sum1
  return result
  
  
def printSharedMemory():
  print "datain:"
  data = jlink.com_read_16bit_block(sharedMemoryDataIn,
                                    sharedMemoryDataInSize16bits+2)[0]
  print ["%04X "%(x) for x in data]
  print "dataout:"
  data = jlink.com_read_16bit_block(sharedMemoryDataOut,
                                    sharedMemoryDataOutSize16bits+2)[0]
  print ["%04X "%(x) for x in data]
  print "command: %04X"%(jlink.com_read_16bit_block(sharedMemoryCommand,1)[0][0])
  print "status:  %04X"%(jlink.com_read_16bit_block(sharedMemoryStatus,1)[0][0])
  
  
def printInfoBlocks():
  print "InfoBlocks:"
  data = jlink.com_read_16bit_block(0x08040000, 0x1000/2)[0]
  print ["%04X "%(x) for x in data]
  
  
def verifyStatus(desiredStatus):
  status = jlink.com_read_16bit_block(sharedMemoryStatus,1)[0][0]
  if(status != desiredStatus):
    print "Verify Status Failed %04X!=%04X"%(status,desiredStatus)
    print "   found: %s, desired: %s"%(cmdstatDict[status], cmdstatDict[desiredStatus])
  
  
def verifyCommand(desiredCommand):
  command = jlink.com_read_16bit_block(sharedMemoryCommand,1)[0][0]
  if(command != desiredCommand):
    print "Verify Command Failed %04X!=%04X"%(command,desiredCommand)
    print "   found: %s, desired: %s"%(cmdstatDict[command], cmdstatDict[desiredCommand])
  
  
def verifyMemoryBeforeProgramming(data, command):
  readback = jlink.com_read_16bit_block(sharedMemoryDataOut,
                                        sharedMemoryDataOutSize16bits)[0]
  for i, value in enumerate(readback):
    if(value!=0x0000):
      print "Verify before prog failed: DataOut[%d]!=0x0000"%(i)
  
  readback = jlink.com_read_16bit_block(sharedMemoryDataIn,
                                        sharedMemoryDataInSize16bits)[0]
  for i, value in enumerate(readback):
    if(value!=data[i]):
      print "Verify before prog failed: DataIn[%d]!=%04X"%(i,data[i])
  
  verifyStatus(STATUS_IDLE_AND_READY)
  
  verifyCommand(command)
  
  savedWMD = jlink.com_read_16bit_block(0x0804077E, (0x08040796-0x0804077E)/2)[0]
  return savedWMD
  
  
def verifyMemoryAfterProgramming(savedWMD, data):
  readback = jlink.com_read_16bit_block(sharedMemoryDataOut,
                                        sharedMemoryDataOutSize16bits)[0]
  for i, value in enumerate(readback):
    if(value!=data[i]):
      print "Verify after prog failed: DataOut[%d]%04X!=%04X"%(i,value,data[i])
  
  readback = jlink.com_read_16bit_block(sharedMemoryDataIn,
                                        sharedMemoryDataInSize16bits)[0]
  for i, value in enumerate(readback):
    if(value!=data[i]):
      print "Verify after prog failed: DataIn[%d]%04X!=%04X"%(i,value,data[i])
  
  verifyStatus(STATUS_SUCCESS);
  
  verifyCommand(COMMAND_IDLE)
  
  newWMD = jlink.com_read_16bit_block(0x0804077E, (0x08040796-0x0804077E)/2)[0]
  if(newWMD != savedWMD):
    print "Verify after prog failed! New WMD doesn't match saved WMD"
    print "savedWMD:"
    print savedWMD
    print "newWMD:"
    print newWMD
  
  if(0x55AA != jlink.com_read_16bit_block(0x0804077E, 1)[0][0]):
    print "Verify after prog failed: bad sort marker 1"
  if(0x55AA != jlink.com_read_16bit_block(0x08040792, 1)[0][0]):
    print "Verify after prog failed: bad sort marker 2"
  
  
def programSharedRam(data, command):
  #stuff the input region with the new data
  #the input data is already an array
  jlink.com_write_16bit_block(sharedMemoryDataIn, data)
  
  #blank the output region
  data = []
  for i in xrange(sharedMemoryDataOutSize16bits):
    data.append(0x0000)
  jlink.com_write_16bit_block(sharedMemoryDataOut, data)
  
  #set the status to idle and ready
  jlink.com_write_16bit_block(sharedMemoryStatus, [STATUS_IDLE_AND_READY])
  
  #set the command to the desired operation
  jlink.com_write_16bit_block(sharedMemoryCommand, [command])
  
  
def runRamExe():
  #Refer to the function runRamExe in loader.c for a better explanation
  #Set the interrupt vector table to the RAM image's table
  jlink.com_write_32bit_block(0xE000ED08, [0x20000000])
  #Set the SP to the top of RAM (word aligned)
  jlink.com_write_cpu_reg(jlink.CM3_REG_R13_SP, CSTACK)
  #Set the PC to the RAM entry point
  jlink.com_write_cpu_reg(jlink.CM3_REG_R15_PC, ENTRYPOINT)
  #Single step to bypass some CPU/NVIC corruption scenarios
  jlink.com_step()
  #Set the SP to the top of RAM (word aligned)
  jlink.com_write_cpu_reg(jlink.CM3_REG_R13_SP, CSTACK)
  #Set the PC to the RAM entry point
  jlink.com_write_cpu_reg(jlink.CM3_REG_R15_PC, ENTRYPOINT)
  #run the code
  jlink.com_run()
  #no need to poll for completion, just wait a second
  time.sleep(1)
  #stop the CPU
  jlink.com_stop()
  
  
def runPtp(data, command):
  #this method assumes the device is loaded with code and stopped
  print "Executing Production Test Programming"
  programSharedRam(data, command)
  
  #printSharedMemory()
  #printInfoBlocks()
  savedWMD = verifyMemoryBeforeProgramming(data, command)
  
  print "Running chip..."
  runRamExe()
  
  #printSharedMemory()
  #printInfoBlocks()
  verifyMemoryAfterProgramming(savedWMD, data)
  if(command == COMMAND_READ_MODIFY_WRITE):
    #There is no need to verify the erased InfoBlock addresses because the
    #APTD completely surrounds the WMD and if the erasure failed in some
    #capacity, attempting to program the ATPD would catch it.  There
    #is a chunk of memory above the ATPD that isn't verified by anyone,
    #but it's reasonable to assume this area has been erased and is clean.
    pass
  
  
#------------------------------------------------------------------------------
def loadHexToChip(hexFilePath):
  global ENTRYPOINT
  global CSTACK
  global sharedMemoryCommand
  global sharedMemoryCommandSize16bits
  global sharedMemoryDataIn
  global sharedMemoryDataInSize16bits
  global sharedMemoryDataOut
  global sharedMemoryDataOutSize16bits
  global sharedMemoryStatus
  global sharedMemoryStatusSize16bits
  global ramCodeWorstCaseTimingNormalUs
  global ramCodeWorstCaseTimingRmwUs

  if(not os.path.isfile(hexFilePath)):
    raise Exception("Hex file " + hexFilePath + " not found.")
    
  #write the hex file down to the device
  print "Parsing shared memory information from hex file"
  print "Programming hex file to device"
  for line in open(hexFilePath):
    line = line.strip()
    #Look for our required parameters by matching the string, split on
    #the '=', remove whitespace, and assign the value to the parameter
    if(line.find("#prodtestprog")==0):
      print "Hex file build string:"
      print "   %s"%(line)
    elif(line.find("#ENTRYPOINT=")==0):
      ENTRYPOINT = long(line.split("=")[1].strip(),16)
    elif(line.find("#CSTACK=")==0):
      CSTACK = long(line.split("=")[1].strip(),16)
    elif(line.find("#sharedMemoryCommand=")==0):
      sharedMemoryCommand = long(line.split("=")[1].strip(),16)
    elif(line.find("#sharedMemoryCommandSize16bits=")==0):
      sharedMemoryCommandSize16bits = long(line.split("=")[1].strip(),16)
    elif(line.find("#sharedMemoryDataIn=")==0):
      sharedMemoryDataIn = long(line.split("=")[1].strip(),16)
    elif(line.find("#sharedMemoryDataInSize16bits=")==0):
      sharedMemoryDataInSize16bits = long(line.split("=")[1].strip(),16)
    elif(line.find("#sharedMemoryDataOut=")==0):
      sharedMemoryDataOut = long(line.split("=")[1].strip(),16)
    elif(line.find("#sharedMemoryDataOutSize16bits=")==0):
      sharedMemoryDataOutSize16bits = long(line.split("=")[1].strip(),16)
    elif(line.find("#sharedMemoryStatus=")==0):
      sharedMemoryStatus = long(line.split("=")[1].strip(),16)
    elif(line.find("#sharedMemoryStatusSize16bits=")==0):
      sharedMemoryStatusSize16bits = long(line.split("=")[1].strip(),16)
    elif(line.find("#ramCodeWorstCaseTimingNormalUs=")==0):
      ramCodeWorstCaseTimingNormalUs = long(line.split("=")[1].strip(),10)
    elif(line.find("#ramCodeWorstCaseTimingRmwUs=")==0):
      ramCodeWorstCaseTimingRmwUs = long(line.split("=")[1].strip(),10)
    else:
      #normal address:data pair
      address = long(line.split(":")[0],16)
      data = long(line.split(":")[1],16)
      #print "%08X - %08X"%(address, data)
      jlink.com_write_32bit_block(address, [data])
  
  
#------------------------------------------------------------------------------
def test(jlinkHost):
  jlinkHost = jlinkHost.lower().split(':')
  jlinkMedium = jlinkHost[0]
  jlinkAddress = jlinkHost[1]
  jlinkInterface = "jtag" #remember: JTAG is required for FIB programming
  print "Opening %s JLink connecton at address %s using %s"%(jlinkMedium,
                                                             jlinkAddress,
                                                             jlinkInterface)
  err = jlink.com_open_jlink_connection(jlinkMedium,
                                        jlinkAddress,
                                        jlinkInterface)
  if err:
    raise IOError, "JLink: %s"%(jlink.com_error_to_str(err))
  
  print "The MFB will be erased when testing actual chips.  Perform a"
  print "direct masserase to ensure this state for this testing."
  jlink.com_write_32bit_block(0x40008004, [0x45670123])
  jlink.com_write_32bit_block(0x40008004, [0xCDEF89AB])
  jlink.com_write_32bit_block(0x4000402C, [0x00000001])
  jlink.com_write_32bit_block(0x40008010, [0x00000004])
  jlink.com_write_32bit_block(0x40008010, [0x00000004|0x00000040])
  jlink.com_write_32bit_block(0x4000800C, [0x00000020])
  jlink.com_write_32bit_block(0x4000402C, [0x00000000])
  jlink.com_write_32bit_block(0x40008010, [0x00000080])
  
  print "Unlock TCR to allow programming of the FIB"
  #perform a quick read to ensure the JLink and chip are operating cleanly
  #in JTAG mode
  jlink.com_read_32bit_block(0,1)
  #Unlock the TCR to allow programming of the FIB (this has the nice side
  #effect of toggling nRESET and resetting the entire chip
  jlink.com_assert_reset_pin()
  jlink.jtag_scan_ir(8, [0x3F]) #select TAC OpCode
  value = 0xB5CC                #unlock key
  jlink.jtag_scan_dr(16+1, [(value<<1)&0xFF, (value>>7)&0xFF, (value>>15)&0xFF])
  jlink.jtag_scan_ir(8, [0x4F]) #select TCR OpCode
  value = 0x0008                #set TCR bit 3 (ALLOW_FLASH_MODS)
  jlink.jtag_scan_dr(16+1, [(value<<1)&0xFF, (value>>7)&0xFF, (value>>15)&0xFF])
  jlink.com_deassert_reset_pin()
  #perform a quick read to ensure the JLink and chip are operating cleanly
  #in JTAG mode
  jlink.com_read_32bit_block(0,1)

  print "Reset and capture the CPU"
  jlink.com_reset()
  
  loadHexToChip("./prodtestprog.hex")
  
  print "Building test data"
  for i in xrange(sharedMemoryDataInSize16bits):
    TEST_DATA_INCREMENT.append(i)
  TEST_DATA_INCREMENT[959+53] = 0x5AA5 #ensure RDPROT is cleared
  checksum = calculateFletcher32Checksum(TEST_DATA_INCREMENT)
  TEST_DATA_INCREMENT.append((checksum>>16)&0xFFFF)
  TEST_DATA_INCREMENT.append((checksum>> 0)&0xFFFF)
  for i in xrange(sharedMemoryDataInSize16bits):
    TEST_DATA_FFFF.append(0xFFFF)
  TEST_DATA_FFFF[959+53] = 0x5AA5 #ensure RDPROT is cleared
  checksum = calculateFletcher32Checksum(TEST_DATA_FFFF)
  TEST_DATA_FFFF.append((checksum>>16)&0xFFFF)
  TEST_DATA_FFFF.append((checksum>> 0)&0xFFFF)
  for i in xrange(sharedMemoryDataInSize16bits):
    TEST_DATA_0000.append(0x0000)
  TEST_DATA_0000[959+53] = 0x5AA5 #ensure RDPROT is cleared
  checksum = calculateFletcher32Checksum(TEST_DATA_0000)
  TEST_DATA_0000.append((checksum>>16)&0xFFFF)
  TEST_DATA_0000.append((checksum>> 0)&0xFFFF)
  
  #NOTE:  The following modes are not testable in this framework because they
  #would require either altering the test code itself or poisoning the FIA
  #which would require special programming code.  These modes have been
  #test inside of the PlatformtestFramework.
  #  STATUS_PROG_INHIBIT_FAILURE
  #  STATUS_VERIFY_PROG_FAILURE
  #  STATUS_VERIFY_ERASE_FAILURE
  #  STATUS_SORT_MARKERS_INVALID_FAILURE
  
  print ""
  print ">>> STATUS_SUCCESS  TESTING"
  runPtp(TEST_DATA_INCREMENT, COMMAND_READ_MODIFY_WRITE)
  runPtp(TEST_DATA_0000, COMMAND_READ_MODIFY_WRITE)
  runPtp(TEST_DATA_FFFF, COMMAND_READ_MODIFY_WRITE)
  runPtp(TEST_DATA_INCREMENT, COMMAND_PROGRAM)
  runPtp(TEST_DATA_FFFF, COMMAND_READ_MODIFY_WRITE)
  
  
  print ""
  print ">>> STATUS_INVALID_COMMAND_FAILURE  TESTING"
  jlink.com_write_16bit_block(sharedMemoryCommand, [0x0000])
  print "Running chip..."
  runRamExe()
  verifyStatus(STATUS_INVALID_COMMAND_FAILURE)
  verifyCommand(COMMAND_IDLE)
  
  
  print ""
  print ">>> STATUS_NEW_DATA_CHECKSUM_FAILURE  TESTING"
  #blank the input data region
  data = []
  for i in xrange(sharedMemoryDataInSize16bits):
    data.append(0x0000)
  jlink.com_write_16bit_block(sharedMemoryDataIn, data)
  jlink.com_write_16bit_block(sharedMemoryCommand, [COMMAND_PROGRAM])
  print "Running chip..."
  runRamExe()
  verifyStatus(STATUS_NEW_DATA_CHECKSUM_FAILURE)
  verifyCommand(COMMAND_IDLE)
  
  
  print ""
  print ">>> STATUS_PROG_NOT_EMPTY_FAILURE  TESTING"
  #standard PTP RMW to set the memory to zero
  runPtp(TEST_DATA_0000, COMMAND_READ_MODIFY_WRITE)
  #now try to overlay it with other data
  programSharedRam(TEST_DATA_INCREMENT, COMMAND_PROGRAM)
  print "Running chip..."
  runRamExe()
  verifyStatus(STATUS_PROG_NOT_EMPTY_FAILURE)
  verifyCommand(COMMAND_IDLE)
  
  
#------------------------------------------------------------------------------
if __name__ == '__main__':
  #if we're running standalone, just run the standard test.  The user should
  #supply the hostname for test as the only argument to this script
  try:
    jlinkHost = sys.argv[1]
  except:
    print "This test takes a one argument                                       "
    print "1) The hostname of the JLink to use. The hostname can be of the form:"
    print " usb:0                                                               "
    print " ip:127.0.0.1                                                        "
    raise SystemExit
  
  test(jlinkHost)

