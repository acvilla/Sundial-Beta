#!/usr/bin/env python
#
# This test takes a single argument that is the hostname of the JLink to use.
# The hostname can be of the form:
#  usb:0
#  ip:127.0.0.1
#
# This test code depends on the jlink cygwin package library (installed for
# Salina execution).  The only precondition to running this test code is that a
# production-test.hex file exists in the same directory and has been generated by:
# ./productionTestToHex.py ../../../../build/production-test-ram-cortexm3-iar-em350-em350-dev0680-[BUILD OPTION]-production_test_ram-ramexe/
# This code is capable of programming the chip directly from the hex file
# and executing a variety of tests.
#
# * Copyright 2009 by Ember Corporation.  All rights reserved.              *80*
################################################################################

import os
import sys
import time
import jlink

EXECUTE_COMMAND     = 1
COMMAND_IN_PROGRESS = 2
COMMAND_COMPLETE    = 3

addressMap = {}

def readInt32s(name):
  value = jlink.com_read_32bit_block(addressMap[name][0], 1)[0][0]
  value = (value ^ 0x80000000) - 0x80000000
  return value

def readInt32u(name):
  return jlink.com_read_32bit_block(addressMap[name][0], 1)[0][0]
  
def writeInt32u(name, value):
  jlink.com_write_32bit_block(addressMap[name][0], [value])

def printSharedMemory():
  for name in sorted(addressMap, key=addressMap.get):
    value = readInt32s(name)
    print ("{%s = " + addressMap[name][1] + "}") % (name, value)

def verifyStatus(desiredStatus):
  status = readInt32u("ramControl")
  if status != desiredStatus:
    print "Verify Status Failed %04X!=%04X" % (status, desiredStatus)

def runRamExe():
  #Refer to the function runRamExe in loader.c for a better explanation
  #Set the interrupt vector table to the RAM image's table
  jlink.com_write_32bit_block(0xE000ED08, [0x20000000])
  #Set the SP to the top of RAM (word aligned)
  jlink.com_write_cpu_reg(jlink.CM3_REG_R13_SP, CSTACK)
  #Set the PC to the RAM entry point
  jlink.com_write_cpu_reg(jlink.CM3_REG_R15_PC, ENTRYPOINT)
  #Single step to bypass some CPU/NVIC corruption scenarios
  jlink.com_step()
  #Set the SP to the top of RAM (word aligned)
  jlink.com_write_cpu_reg(jlink.CM3_REG_R13_SP, CSTACK)
  #Set the PC to the RAM entry point
  jlink.com_write_cpu_reg(jlink.CM3_REG_R15_PC, ENTRYPOINT)
  #run the code
  jlink.com_run()

def loadNames(file):
  global addressMap
  namesFile = file
  if(not os.path.isfile(namesFile)):
    namesFile = "../" + namesFile
    if(not os.path.isfile(namesFile)):
      raise Exception("Names file " + namesFile + " not found.")
  address = SHAREDRAM
  for line in open(namesFile):
    name = line.split(",")[0]
    format = line.split(",")[1]
    addressMap[name] = (address, format)
    address += 4

def loadHexToChip(hexFilePath):
  global ENTRYPOINT
  global CSTACK
  global SHAREDRAM
  if(not os.path.isfile(hexFilePath)):
    raise Exception("Hex file " + hexFilePath + " not found.")
  #write the hex file down to the device
  print "Programming hex file to device"
  for line in open(hexFilePath):
    line = line.strip()
    if(line.find("#production-test")==0):
      print "Hex file build string %s" % (line)
    elif(line.find("#ENTRYPOINT=")==0):
      ENTRYPOINT = long(line.split("=")[1].strip(),16)
    elif(line.find("#CSTACK=")==0):
      CSTACK = long(line.split("=")[1].strip(),16)
    elif(line.find("#SHAREDRAM=")==0):
      SHAREDRAM = long(line.split("=")[1].strip(),16)
    else:
      address = long(line.split(":")[0],16)
      data = long(line.split(":")[1],16)
      #print "%08X - %08X"%(address, data)
      jlink.com_write_32bit_block(address, [data])

def test(jlinkHost, testNum, cmdNum):
  jlinkHost = jlinkHost.lower().split(':')
  jlinkMedium = jlinkHost[0]
  jlinkAddress = jlinkHost[1]
  jlinkInterface = "jtag" #remember: JTAG is required for FIB programming
  print "Opening %s JLink connecton at address %s using %s"%(jlinkMedium,
                                                             jlinkAddress,
                                                             jlinkInterface)
  err = jlink.com_open_jlink_connection(jlinkMedium,
                                        jlinkAddress,
                                        jlinkInterface)
  if err:
    raise IOError, "JLink: %s"%(jlink.com_error_to_str(err))

  jlink.com_toggle_reset_pin()
  #perform a quick read to ensure the JLink and chip are operating cleanly
  #in JTAG mode
  jlink.com_read_32bit_block(0,1)

  print "Reset and capture the CPU"
  jlink.com_reset()

  loadHexToChip("./production-test.hex")
  loadNames("./production-test-names.txt")

  print "Running chip..."
  runRamExe()
  time.sleep(1)
  jlink.com_stop()
  writeInt32u("test", testNum)
  writeInt32u("cmd", cmdNum)
  writeInt32u("ramControl", EXECUTE_COMMAND)
  #printSharedMemory()
  jlink.com_run()
  print "Running test..."
  time.sleep(1)
  jlink.com_stop()
  stopAddress = jlink.com_read_cpu_reg(jlink.CM3_REG_R15_PC)
  print "Stop address %x" % (stopAddress)
  verifyStatus(COMMAND_COMPLETE)
  printSharedMemory()


#-------------------------------------------------------------------------------
if __name__ == '__main__':
  #if we're running standalone, just run the standard test.  The user should
  #supply the hostname for test as the only argument to this script
  try:
    jlinkHost = sys.argv[1]
    testNum = int(sys.argv[2])
    cmdNum = int(sys.argv[3])
  except:
    print "Usage: " + sys.argv[0] + " jlinkHost testNum cmdNum"
    print "jlinkHost must be in the form of 'usb:0' or 'ip:127.0.0.1'"
    raise SystemExit
  
  test(jlinkHost,testNum,cmdNum)
